import numpy as np
import torch
# import matplotlib.pyplot as plt
from scipy.io import loadmat, savemat
import pandas as pd
import scipy.special as SS
import scipy.stats as SSA
import copy
import random
import math
import sys
from sklearn.model_selection import ParameterGrid
import gzip
from torch_geometric.data import Data
from branching_gnn_V3 import *


def main():
    s = sys.argv[1]
    s = int(s)  # parameter index
    es_idx = int(sys.argv[2])  # ensemble index
    # load data
    WN = np.loadtxt('W_avg.csv')
    pop = np.loadtxt('pop_new.csv')
    para_dict = np.load('para_dict.npy', allow_pickle=True)
    # set parameters
    para_i = para_dict[s]
    R0 = para_i['R0']
    r = para_i['r']
    p = r/(R0+r)
    num_fips = len(pop)
    T = 60
    # initialize variables
    # seeding
    l0 = 1859-1  # start with New York County NY in python -1, in matlab is 1859
    i0 = 100  # the starting t=0, in matlab it is 1
    # number of nodes, the columns of attributes
    xx = np.zeros((num_fips, T+2))
    xx[:, 1] = pop  # populations
    # col_2 is the new infections generated by the new infectors
    xx[l0, 2] = 100  # the new infections at time 0 in the seeding location
    xx = torch.tensor(xx, dtype=torch.float)

    adjacency_matrix = torch.tensor(WN)
    # Get the indices where the adjacency matrix has a non-zero value
    edge_index = torch.nonzero(adjacency_matrix, as_tuple=False).t()
    # If adjacency matrix has edge weights, you can get them like this:
    edge_weight = adjacency_matrix[edge_index[0], edge_index[1]]
    data = Data(x=xx, edge_index=edge_index, edge_attr=edge_weight)

    torch.manual_seed(es_idx)
    E_NewInf_i, _ = simulate_dynamics(
        data, R0=R0, r=torch.tensor(r), num_steps=T)
    save_dir = '/rds/general/user/qy1815/ephemeral/gnn_version/branching_R0-{}_r-{}/' .format(
        np.round(R0, 2), np.round(r, 3))
    f = gzip.GzipFile(
        save_dir+"NewInf_R0-{}_r-{}_{}.npy.gz" .format(np.round(R0, 2), np.round(r, 3), es_idx), "w")
    np.save(file=f, arr=E_NewInf_i[:, 2:])
    f.close()


if __name__ == "__main__":
    main()
